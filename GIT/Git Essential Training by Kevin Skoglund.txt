Understanding version control:

Git is software that keeps track of changes that you make to files and directories, and it is especially good in keeping track of text changes that you make.

Because what it does is manage versions for you, Git is referred to as a Version Control System or VCS for short. 

About distributed version control:

Git is Distributed Version Control, different users --or teams of users--each maintain their own repositories instead of working from a central repository. And the changes are stored as change sets or patches, and we're focused on tracking changes not the versions of the document.

SCSS, RCS, CVS, and SVN:
And all four of these use a central code repository model, that is that there is one central place where you store the master copy of your code, and when you're working with the code you check out a copy from the master repository. You work with it make your changes, and then you submit those changes back to the central repository.

Other users can also work from that repository submitting their changes. And it's up to us as users to keep up-to-date with whatever is happening in that central code repository, to make sure that we pull down and update any changes that other people have made.

Git doesn't work that way, Git is Distributed Version Control, different users --or teams of users--each maintain their own repositories instead of working from a central repository. And the changes are stored as change sets or patches, and we're focused on tracking changes not the versions of the document.

Now that's a subtle difference, you may think, well, CVS and SVN those track changes too, they don't. They track the changes that it takes to Git from version-to-version of each of the different files or the different states of a directory. Git doesn't work that way, Git really focuses on these change sets in encapsulating a change set as a discrete unit and then those change sets can be exchanged between repositories.

We're not trying to keep up-to-date with the latest version of something instead the question is, do we have a change set applied or not? So there is no single master repository, there is just many working copies each with their own combination of change sets. Let me give an illustration to make this clear.

And if you decide you don't like the way that a open source project is going, you can fork it, take it to a completely different direction and say, you know what, I'm going to just make a clean break and make my repository now the one that I'm going to work from, all of my changes will be submitted to there, and I can still pull change sets from the master one into my project whenever I want. But I don't have to, I can go my own way. That becomes a really powerful and flexible feature that's well suited to collaboration between teams especially loose groups of distributed developers like you have in the open source world. Distributed version control is an important part of the Git architecture that you need to keep in mind.


just make sure that you understand that there is no central repository that we were from, all repositories are considered equal by Git, it's just a matter of whether a repository has change sets in it or doesn't.
 
GIT is not a SVN tool, else it is distributed version control tool. So no central repository.


Who should use Git?:

it's really for anyone who wants to track edits, especially edits for text documents. It offers you the ability to review a log of changes that were made, to view differences between versions, and to retrieve old versions. Those features are not just limited to programmers, those are things that anyone working with the text file might want to be able to do.

It doesn't work well with files that have to be interpreted by an application, word processing file, spreadsheets, PDF's, Photoshop PSD's, these kinds of files need an application to interpret them otherwise they're just a bunch of letters and numbers that Git won't understand. 

So Git will again keep track of the fact that you've a Microsoft Word file in version 1 and in version 2, but it won't be able to show you the difference, the text that you changed between those two files.

Git is VCS version control system.
SVN and VCS are different things.


Installing Git on Windows:

The URL for that's http://git-scm.com--the scm, stands for source code management

Artilce for setting up GIT on windows
https://help.github.com/en/articles/set-up-git

GitBash -> Git Unix (Bash is Unix environment)
It is just like unix.

dir	 		for getting directory files

which git 	tells you where git is installed.

git --version	give you version of git installed.


Configuring Git:

We can save configuration on following levels.
1. System level configuration. 
2. User level configuration. 
	it is single user configuration and mostly used. in Windows it is saved at $HOME\.gitconfig
3. Project by project basis.
	they apply only to that specific project
	location is my_project/.git/config
	
command to config these files 
git config --andLevelWhereYouWantToConfi
like
git config --system

User level:
git config --global
i.e global to the user.

Project
git config

For adding User name:
$ git config --global user.name "Vikas Singh"

For adding email:
$ git config --global user.email "vandevikas@gmail.com"

for getting list of configrations done
git config --list

for getting specific config
git config user.name
git config user.email

cat .gitconfig	
will give you what the config file saves

don't know more about it:
git config --global core.editor "notepad.exe"

for setting the colors to the console of git
git config --global color.ui true

Exploring Git auto-completion:
Skipped for Windows as it already has this capability.


git help
will show you all git commands and all

git help andTheCommandForWhichYouNeedHelp


Initializing a repository:

git init
will setup the directory as homebase and make it as a Git repository and track all the files that come and go, changes done in this directory.


Understanding where Git files are stored:
git init command creates a .git directory inside the folder, and this .git folder contains many file and folders with which we don't need to mess.

Only one file is of importance is config, it is project level configrations. We can edit this file as well.

Performing your first commit:
git add .
. is for this directory.
and git add will look for every change in this directory.

git commit -m "Initial Commit"
to add the change in repository or permenent memory.

~Till Now we have not defined the location in GITHUB where this changes will be saved so they might be saved locally.

So the basic process is:
1. make changes.
2. add the changes.
3. commit the changes to the repository with a message.


Writing commit messages:
good descriptive commit message.

commit message in present tense, as this is regarding the change. 


Viewing the commit log:
git log
gives you all the commit logs

git help log -> to get help

git log -n 1 -> will return only one commit comment

git log --since=2012-06-15 -> will return all comments since that date.

git log --until=givenDate -> will return all comments till that date.
 
git log --author="Vikas" -> can give partial name of the specific author.

git log --grep="Any Expression or String in the commit"
grep -> global regular expression search
Will return commit containing that message.
Can be of use if you want to search anything with help of commit.


Exploring the three-trees architecture:

two tree architecture -> other version control system use.

1. repository and 2. working copy.

checkout from repository to working copy.
and commit to repository from working copy.

Git has 3 tree architecture:
1. repository 2. staging index 3. working

staging index is extra in case of GIT.

repository
staging index		2. git commit file.txt
working				1. git add file.txt

we first move the file from working copy to staging index and then commit the file from staging index to repository.

we can skip staging index step that we will learn later.


Git Workflow:
is explained above.


Using hash values (SHA-1):
Change set 

SHA-1 hash algrithm to create checksums.
it creates the commit id. that we see with commit.

Working with the HEAD pointer.

Git maintains a HEAD pointer which is a refrence variable.

only points to current branch in repository and not staging or working copy.

it points to last state of repository.

head always points to latest commit in the repository and for any commit it will add after that making it parent of that commit.

Head is the tip of currently checked out branch in the repository.

git log HEAD 


Adding files:
git status
gives us the difference between working copy, staging index and repository.

it gives the status of staging directory and repository.

Editing files:
same process.
like 
git add fileName.txt

Viewing changes with diff:
In unix diff is used to compair 2 files.

git diff
will compair old version and new version.
i.e will compair the file in repository i.e where the head is pointing at, with the file in our working copy.

- is the line removed in working directory file
+ is lines added in local file

i.e only shows the changes.

also shows line numbers 

git diff -> will show all the changes in all the files.

git diff fileName.txt -> will show only changes in perticular file.


Viewing only staged changes:
Actually
if you edit a file in working directory and do git diff you will see the changes.
But now if you do git add and move this file to staging index and then do git diff then you will see no difference i.e. git diff only compairs files in stagigning and working dir.

git diff --staged
to see difference between staging and repository.

So if you have added your changes by git add and then you want to see the difference then you have to see it in staging index via --staged.

Deleting files:
from repository

2 ways to delete file from repo:
First way:
1. Delete the file manually from working directory.
2. do git status and you will see that file is showing as in red and deleted:
3. use -> git rm fileToDelete.txt
4. git status will now show in green that file is deleted from staging.
5. git commit -m "Commit the deletion changes into the repo"
6. git status will now not show anything about that file.

rm -> remove.
It is just like adding changes just opposite in action, i.e remove changes.

Second Way:
1. git rm fileToDelete.txt
Unix will completely delete the file from your system.
2. git status
You will see a message deleted: fileToDelete.txt
i.e. by git rm fileToDelete we moved to staging area.
3. git commit -m "Removing file from repo"

it is simple way i.e 1. rm file and then 2. commit the deletion step.

Moving and renaming files:
2 Ways:

Just like deletion of file first way is to manually do the step and let git find out what changed.
Second way is to do it via git.

1. Manual Renaming of file:

1. If you rename a file and do git status
than you see that the file you renamed is deleted and the git shows there is one new file added i.e. untracked files is added.

git shows:
deleted: fileIWantToRename.txt
Untracked files: renamedFile.txt

2. Now add that new file to staging.
and remove renamed file.
i.e. 
git add renamedFile.txt
git rm fileIWantToRename.txt

3. git status
will show you that renamedFile.txt is renamed to fileIWantToRename.txt
renamed: xyz.txt -> zyx.txt

4. Now commit the changes.

Second way: Git doing it for you.






















































